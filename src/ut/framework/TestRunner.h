#ifndef KERNEL_UT_FRAMEWORK_TEST_RUNNER_H_INCLUDED
#define KERNEL_UT_FRAMEWORK_TEST_RUNNER_H_INCLUDED

#include "TestSuite.h"
#include "TestResult.h"
#include "Printer.h"

namespace kernel {

class UnitTestingAssert;
class TestSuite;

class TestRunner {
	friend TestRunner& getSingleInstance<TestRunner>();
	friend class UnitTestingAssert;
public:
	void addTestSuite(TestSuite& suite, const char* name);
	void run(TestResult& result);

	/**
	 * Do not display any information when running test cases
	 */
	void keepQuiet() {
		quiet = true;
	}

	/**
	 * Display detailed information when running test cases
	 */
	void verbose() {
		quiet = false;
	}

	bool isQuiet() {
		return quiet;
	}

	void stopWhenFailed(bool b) {
		stop = b;
	}

private:
	class MessageStream {
	public:
		MessageStream(TestRunner& r) : console(getSingleInstance<Printer>()),
				runner(r) {
		}

		template<typename T>
		MessageStream& operator << (T& data) {
			if (!runner.isQuiet()) {
				console << data;
			}
			return *this;
		}

	private:
		Printer& console;
		TestRunner& runner;
	};

	TestRunner(const TestRunner&);
	const TestRunner& operator = (const TestRunner&);

	enum {
		MAX_TEST_SUITE = 128
	};

	MessageStream message;
	bool quiet;
	int totalSuite;
	TestResult* result;
	bool stop;
	int totalAssertion;
	int failedAssertion;
	TestSuite* testSuite[MAX_TEST_SUITE];
	const char* testSuiteName[MAX_TEST_SUITE];


	/**
	 * The implementation of the method will be generated by the shell script
	 * "GenerateTestSuite.sh"
	 */
	void installTestSuite();

	void runTestSuite(TestSuite& suite);

	void runTestCase(TestSuite& suite, int testCaseId);

	TestRunner() : message(*this), quiet(false), totalSuite(0), result(0),
			stop(false), totalAssertion(0), failedAssertion(0) {
		installTestSuite();
	}

	void prepareForTesting() {
		totalAssertion = 0;
		failedAssertion = 0;
	}

	void saveTestingResult() {
		result->totalCase++;
		result->totalAssertion += totalAssertion;
		result->failedAssertion += failedAssertion;
	}

	bool shouldStopTesting() const {
		return failedAssertion > 0 && stop;
	}

	bool isTestPointClean() const {
		return failedAssertion == 0;
	}

	void assertionSucceeded() {
		result->totalAssertion++;
	}

	void showFailedMessage(const char* file, int line,
			const char* expression) {
		message << file << ":" << line << " " << expression << " FAILED\n";
	}

	void showFailedMessage(const char* file, int line, const char* actual,
			const char* expected) {
		message << file << ":" << line << " " << actual << " == "
				<< expected << " FAILED\n";
	}

	void assertionFailed(const char* file, int line,
			const char* expression) {
		result->failedAssertion++;
		result->totalAssertion++;
		showFailedMessage(file, line, expression);
	}

	void assertionFailed(const char* file, int line,
				const char* actual, const char* expected) {
		result->failedAssertion++;
		result->totalAssertion++;
		showFailedMessage(file, line, actual, expected);
	}
};

} /* namespace kernel */

#endif /* KERNEL_UT_FRAMEWORK_TEST_RUNNER_H_INCLUDED */
